# Chapter 7 Evaluating Expressions

## 解释器实现
终于，在这一节完成之后，就能够得到一个真正可用的解释器，它对源文件进行扫描，得到 token，然后通过语法规则构建出 token 树，后续遍历 token 树，对左右孩子进行解释，得到表达式的结果，遍历完所有树节点之后，就能够得到一个最终的解释结果。当然，这个解释器还是不是一门语言的解释器，而是一个简单的计算器，因为他现在只能够解析简单的数学表达式，比如 `(10+20)/2 + 6/2`

解释器工作：
```Python
>>> 10+10
20
>>> (10+20)/2+5*3
30
>>> 5/2
2.5
>>> "my"+"name"+"is"+"lkx"
mynameislkx
>>> "my"+123
Operands must be two numbers or two strings
[line 1]

```

有了前两章的基础之后，解释过程反而是最简单的一章，具体过程和之前 AstPrinter 的执行过程是一样的，都是遍历左右节点，然后做出父节点定义的操作。有一些实现细节需要注意：
1. 因为要对 token 做真正的计算，这里就不能在 token 层级上做操作，而是需要取得 token 里的 literal 值来操作，转换成真正的数字和字符串，再进行运算。
2. 错误处理：在 interpret 阶段得到的错误称为 Runtime Error，因为 Lox 是一门动态语言，所以很多类型需要等待真正运行的时候才能确定，在解释阶段遇到的错误需要抛出，并且最好不要终止整个程序。这里在处理二元表达式的时候，作者书中的检查操作符两边是否是数字时的方式很奇怪，重复了很多遍同一个函数调用，而不是在一开始就排除特殊情况，然后再做检查，这样可以避免这种语句的多次重复。
3. 设计理念问题：是否在执行一些表达式的时候做隐形的类型转换？这是一个语言的决策，像 JS 在这方面就做了很多类型隐形转换，导致比较时会有非常多的意料之外的情况发生。但是本书的作者还是倾向于不做任何隐形的自动转换。

这一章结束之后，就已经搭起来整个解释器的骨架，在之后只要逐渐向上加功能即可。