# Chapter 5 Representing Code

上一节 Scanner 是从**词法**的角度去解析代码源文件，这一节是从**句法**的角度来解析代码，为下一节的真正 Parser 打下基础。
这一节的难点在于两个：
1. 对于句法的抽象。
2. 对于访问者设计模式的实现。
3. 元编程

## 对于句法的抽象
（下文中可能会交替使用句法和语法两个词语，这两个词语在下文可以认为是等同的）

一个表达式：`var name = “mike”` 应该如何去理解它的构成？
从 Scanner 的角度，我们可以将它分解成四个 Token，每一个 Token 有其类型，字面量等属性。但是这些扁平的 Token 序列是如何构成代码真正的含义的呢？
从 Token 去尝试理解句法是很困难的，因为句法是比 Token 更高层级的表示。

可以从我们日常生活中对语言的使用来类比理解，我们有三个词：“我”，“喜欢”，“香蕉”，这里我们得到了三个词语，那么应该如何将这三个词语去构成一条有意义的语句呢？我们知道主谓宾这样的语法，所以我们可以形成：”我喜欢香蕉“，”香蕉喜欢我“，这种话，然后根据现实情况去选择正确的”我喜欢香蕉“。
实际情况下，我们不是**从词语来拼凑语句**的，我们是**从语法来生成语句**的，这也就是我上面说的**句法是比 Token 更高层级的表示**。

所以为了真正理解一系列 Token 的含义，我们应该先**定义语法**，在这一章中，先定义了最简单的四个语法：
1. Binary
2. Grouping
3. Literal
4. Unary

有了这四条语法规则，我们就能够生成简单的表达式：
```Python
e = Binary(Unary(Token(TokenType.MINUS,"-",None,1),
                     Literal(123)),
                 Token(TokenType.STAR,"*",None,1),
                 Grouping(Literal(45.67))
                     )

ast_printer = ast_printer()
ast_printer.print(e)

// 会输出
// (* (- 123) (group 45.67))
```

在实现上，我们定义一个 Expr 基类，然后通过继承基类，定义每一个子类为一个语法，每一个子类持有语法所需要的对象类型，每一个子类需要有对应的方式进行 `interpret()`。

## 访问者模式

访问者模式主要用于给一系列复杂的对象添加方法，但是每一个方法的实现都不同，所以采用重载父类方法的方式也作用不大。

访问者模式定义了一个访问者接口，实现这个接口以及其中的方法，就可以为每一个对象实现一个方法，或者说一项操作。在一系列类中，我们定义对应的接收访问者 `accpet(v:visitor)` 方法，但是不给定参数类型和返回值（通过多态确定对象类型，通过泛型定义返回值）。

这样将一系列对象的方法都集成在访问者的对象中，能够起到**职责分离**的作用。因为这里每一个类都可能会涉及好几种领域的操作，比如打印语法树，比如对表达式进行解释等等。如果把多个职责的代码都写在这些类中，那么会导致每一个类都非常臃肿，降低可维护性。

## 元编程

这是我第一次接触元编程，从我的理解来看，元编程就是通过代码生成代码。如果发现了代码中有重复度很高的模板代码，作为软件工程师，就自然会想到如何去自动化这样的重复操作。元编程的本质就是在操纵字符串，只要有清晰的生成结果的样例，编写起来也并不难。